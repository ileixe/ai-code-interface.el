* AI Code Interface

An Emacs interface for AI-assisted software development, designed to integrate seamlessly with *AI-driven agile development workflow*. The purpose is to provide a uniform interface and experience for different AI backend.

- Current it support these two backends:
  - Claude Code
  - Gemini CLI
  - OpenAI Codex CLI

- I use different CLI based AI tool in emacs: Claude Code / Gemini CLI / Aider. If you also use different AI tools inside emacs, but want to keep same user interface and experience, this package is for you.

- Lots of feature and tool ported from [[https://github.com/tninja/aider.el][aider.el]], if you like the feature in aider.el, but wish to switch to Claude Code or Gemini CLI, this package is also for you.

** Installation

*** Using straight.el (Recommended)

#+begin_src emacs-lisp
(use-package ai-code-interface
  :straight (:host github :repo "tninja/ai-code-interface.el")
  :config
  ;; Enable global keybinding for the main menu
  (global-set-key (kbd "C-c a") #'ai-code-menu)
  
  ;; Optional: Set up Magit integration for AI commands in Magit popups
  (with-eval-after-load 'magit
    (ai-code-magit-setup-transients)))
#+end_src

** Usage

*** Backend Configuration
    This package acts as a generic interface that requires a backend AI assistant package to function. You can configure it to work with different backends.

**** claude-code.el (Default)
    It is designed to work out-of-the-box with `claude-code.el`.

    First, ensure you have `claude-code.el` installed and configured. You can get it from https://github.com/stevemolitor/claude-code.el.

    `ai-code-interface` will automatically use it, as it defaults to aliasing its core functions to `claude-code.el`'s functions.

**** gemini-cli.el
    To use `gemini-cli.el` as the backend, first install it from https://github.com/linchen2chris/gemini-cli.el.

    Then, add the following configuration to your Emacs setup to override the defaults:
    #+begin_src emacs-lisp
    (with-eval-after-load 'ai-code-interface
      (require 'gemini-cli)
      (defalias 'ai-code-cli-start #'gemini-cli-mode)
      (defalias 'ai-code-cli-switch-to-buffer #'gemini-cli-switch-to-buffer)
      (defalias 'ai-code-cli-send-command #'gemini-cli-send-command))
    #+end_src

**** claude-code-ide.el
    To use `claude-code-ide.el` as the backend, first install it from https://github.com/manzaltu/claude-code-ide.el.

    Then, add the following configuration to your Emacs setup:
    #+begin_src emacs-lisp
      (with-eval-after-load 'ai-code-interface
        (require 'claude-code-ide)
        (defalias 'ai-code-cli-start #'claude-code-ide--start-if-no-session)
        (defalias 'ai-code-cli-switch-to-buffer #'claude-code-ide-switch-to-buffer)
        (defalias 'ai-code-cli-send-command #'claude-code-ide-send-prompt))
    #+end_src

    You can adapt this pattern for other AI assistant packages by changing the functions in the `defalias` calls.

**** OpenAI codex CLI

    Then, add the following configuration to your Emacs setup:
    #+begin_src emacs-lisp
      (with-eval-after-load 'ai-code-interface
        (require 'ai-code-codex-cli)
        (defalias 'ai-code-cli-start #'codex-cli)
        (defalias 'ai-code-cli-switch-to-buffer #'codex-cli-switch-to-buffer)
        (defalias 'ai-code-cli-send-command #'codex-cli-send-command))
    #+end_src

*** Main Entry Point
    Press `C-c a` to open the main transient menu, which provides access to all major features.

*** Typical Workflows
    - *Changing Code*: Position the cursor on a function or select a region of code. Press `C-c a`, then `c` (`ai-code-code-change`). Describe the change you want to make in the prompt. The AI will receive the context of the function or region and your instruction.
    - *Implementing a TODO*: Write a comment in your code, like `;; TODO: Implement caching for this function`. Place your cursor on that line and press `C-c a`, then `i` (`ai-code-implement-todo`). The AI will generate the implementation based on the comment.
    - *Asking a Question*: Place your cursor within a function, press `C-c a`, then `q` (`ai-code-ask-question`), type your question, and press Enter. The question, along with context, will be sent to the AI.
    - *Refactoring a Function*: With the cursor in a function, press `C-c a`, then `r` (`ai-code-refactor-book-method`). Select a refactoring technique from the list, provide any required input (e.g., a new method name), and the prompt will be generated.
    - *Reviewing a Pull Request*: Press `C-c a`, then `v` (`ai-code-pull-or-review-diff-file`). Choose to generate a diff between two branches. The diff will be created in a new buffer, and you'll be prompted to start a review. 

*** The Prompt File
    Use `M-x ai-code-open-prompt-file` to open or create `.ai.code.prompt.org` at the root of your Git repository. This file is an Org-mode buffer where you can write, edit, and manage your prompts. Press `C-c C-c` (`ai-code-prompt-send-block`) on a block of text to send it directly to the AI.

** Key Features

- *Interactive AI Chat*: Start an interactive session with an AI assistant in a dedicated Emacs buffer.
- *Context-Aware Prompting*: Automatically include relevant context in your prompts, such as file paths, selected code regions, or the current function.
- *Code Manipulation*:
  - *Change Code*: Request changes to the current function or a selected region.
  - *Implement TODOs*: Automatically generate code to fulfill `TODO` comments.
  - *Explain Code*: Get explanations for a symbol, line, function, file, or selected region.
  - *Fix Errors*: Use `Flycheck` integration to automatically generate fixes for reported errors.
- *Agile Development*:
  - *TDD Cycle*: A guided workflow for the Red-Green-Refactor cycle of Test-Driven Development.
  - *Refactoring*: Apply common refactoring techniques (e.g., Extract Method, Rename Variable) with AI assistance.
- *Git & Magit Integration*:
  - *Review Diffs*: Generate and review diffs for commits, branches, or staged changes.
  - *Analyze History*: Use `git blame` and `git log` output to get AI-powered insights into code evolution and contributor patterns.
  - *Transient Menus*: Access AI commands directly from the Magit interface.
- *Prompt Management*:
  - *Prompt File*: Use a dedicated `.ai.code.prompt.org` file to manage and reuse prompts.
  - *Snippets*: Leverage `yasnippet` for a library of predefined, reusable prompts.
- *Usability Enhancements*:
  - *Transient Menu*: A clean, organized menu (`C-c a`) for easy command discovery.
  - *Helm/Completing-Read*: Enhanced input completion with history.
  - *Clipboard Utilities*: Easily copy file paths (formatted for AI prompts) and open clipboard paths in Dired.

** [[https://github.com/tninja/aider.el/blob/main/appendix.org#be-careful-about-ai-generated-code][Why Agile development with AI?]]

** Dependencies

*** Required Dependencies
- Emacs 26.1 or later
- `org`: Org-mode support
- `magit`: Git integration
- `transient`: For the menu system

*** Optional Dependencies
- `helm`: For an enhanced auto-completion experience (`ai-code-input.el`).
- `yasnippet`: For snippet support in the prompt file. A library of snippets is included.
- `gptel`: For intelligent, AI-generated headlines in the prompt file.
- `flycheck`: To enable the `ai-code-flycheck-fix-errors-in-scope` command.

** License

Apache-2.0 License

** Contributing

Contributions, issue reports, and improvement suggestions are welcome! Please open an issue or submit a pull request on the project's GitHub repository.
